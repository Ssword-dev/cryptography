{
  "version": 3,
  "sources": ["../src/sea.ts"],
  "sourcesContent": ["import { Buffer } from \"node:buffer\";\r\n\r\n// config\r\nconst config = {\r\n  initialValues: new Uint32Array([\r\n    // for those who are reading this code wondering\r\n    // why the constants, the weird constants are chosen\r\n    // for uniqueness and also for the funny.\r\n    // like legit, i chose pluto demotion timestamp. idk why\r\n    // but somehow it works.\r\n    696342, // sun's radius\r\n    Math.floor(3.86e26 % 0xffffffff) >>> 0, // sun luminosity wrapped\r\n    Math.floor(Math.sqrt(4.5682 * 4_568_200_000)) >>> 0, // earth distance\r\n    Math.floor(Math.sqrt(1156377600000)), // Pluto demotion timestamp\r\n    Math.floor(Math.sqrt(9_460_730_472)), // lightyear constant\r\n\r\n    // serious constants. no but actually, these adds entropy.\r\n    // the other funny constants are fine because well, it also\r\n    // adds entropy, cuz its results are also square roots\r\n    // of a constant. but primes help a ton.\r\n    Math.floor(Math.sqrt(4294967231)), // prime 1\r\n    Math.floor(Math.sqrt(4294967279)), // prime 2\r\n    Math.floor(Math.sqrt(4294967291)), // prime 3\r\n  ]),\r\n  rotLeftAmount: 5,\r\n  rotRightAmount: 3,\r\n  nlConstants: {\r\n    // first multiplication\r\n    scale: 0xb7e15162,\r\n\r\n    // second multiplication\r\n    grow: 0x9e3779b9,\r\n\r\n    // flip (entropy up)\r\n    flip: 0x7f4a7c15,\r\n\r\n    // collapse (entropy collapse)\r\n    collapse: 0x243f6a88,\r\n  },\r\n\r\n  // number of left rotations.\r\n  nlShift: 7,\r\n\r\n  // higher rounds = better entropy.\r\n  roundsPerByte: 3,\r\n};\r\n\r\n// utils\r\n\r\n// wrap to 32 bit.\r\n// aka wrap to 32 bit ULL.\r\nconst wrap32 = (x: number): number => x >>> 0;\r\n\r\n// rotate left\r\nconst rotL = (x: number, n: number): number =>\r\n  ((x << n) | (x >>> (32 - n))) >>> 0;\r\n\r\n// rotate right\r\nconst rotR = (x: number, n: number): number =>\r\n  ((x >>> n) | (x << (32 - n))) >>> 0;\r\n\r\n// zeta\r\nconst zetaValue = (alpha: number, beta: number): number =>\r\n  (alpha ^ beta) + (alpha & beta);\r\n\r\n// high entropy non linear function.\r\n// produces gamma.\r\nconst gammaValue = (alpha: number, beta: number, u: number): number => {\r\n  // get constants\r\n  const { scale, grow, flip, collapse } = config.nlConstants;\r\n\r\n  // z is our gamma value. its the non linearity of alpha\r\n  // and beta with respect u.\r\n  // initializes to ULL32 value of scale multiplied\r\n  // by the zeta of alpha and beta left shifted 3 places.\r\n  let z = wrap32((scale * zetaValue(alpha, beta)) << 3);\r\n\r\n  // grows ganna with respect to u and the grow constant.\r\n  z = (z + u * grow) >>> 0;\r\n\r\n  // flip the gamma with the flip constant\r\n  // through XOR (high entropy through iterations)\r\n  z = rotL(z ^ flip, config.nlShift);\r\n\r\n  // collapses gamma value.\r\n  z = wrap32(z & collapse);\r\n  return z;\r\n};\r\n\r\n// produces a hash for a state\r\n// this is the value of the state\r\n// without a key.\r\n// is a mix of linear and non linearity.\r\n// there is 2 linear values alpha and beta\r\n// that is added to the gamma value while wrapping.\r\n// the gamma value is a high non linearity value with respect\r\n// to the variables alpha, beta, and the current byte.\r\n// with gamma's high entanglement to the variables, its pretty hard\r\n// to crack i hope.\r\nconst hashByte = (b: number, u: number): number => {\r\n  // alpha value.\r\n  const alpha = rotL(b ^ u, config.rotLeftAmount);\r\n\r\n  // beta value.\r\n  const beta = rotR(wrap32(b + u), config.rotRightAmount);\r\n\r\n  // gamma value. non linearity layer.\r\n  const gamma = gammaValue(alpha, beta, u);\r\n\r\n  // return alpha + beta + gamma\r\n  return wrap32(alpha + beta + gamma);\r\n};\r\n\r\n// wrapper for hashByte, round trips calls of hashByte for\r\n// higher entropy.\r\nconst roundMix = (b: number, u: number): number => {\r\n  let val = b;\r\n  for (let i = 0; i < config.roundsPerByte; i++) {\r\n    val = hashByte(val, u);\r\n  }\r\n  return val;\r\n};\r\n\r\n// rotates each state using M for higher entropy.\r\nconst entangle = (u: number, args: Uint32Array): number => {\r\n  let prev = args[0];\r\n  for (let i = 1; i < args.length; i++) {\r\n    prev = roundMix(wrap32(prev + args[i]), u);\r\n  }\r\n  return prev;\r\n};\r\n\r\n// produces key offset. increases entropy.\r\n// this is known as caesar shifting.\r\n// now, dont let it fool you, the key drastically\r\n// effects the output even if it's basic caesar shifting\r\n// due to severe avalanche effect.\r\nconst shiftValue = (b: Uint8Array, i: number): number => b[i % b.length] || 0;\r\n\r\n// hashes raw buffers. will not work in browser.\r\n// optimized for node.\r\nfunction sea256Raw(bytes: Buffer, key: Buffer): Buffer {\r\n  const state = config.initialValues.slice(); // clones the initial values.\r\n  let i = 1; // index.\r\n\r\n  for (const u of bytes) {\r\n    const k = shiftValue(key, i); // produce caesar shift.\r\n\r\n    // for each state, update.\r\n    for (let j = 0; j < state.length; j++) {\r\n      // activates the character hashing algorithm.\r\n      // adds the caesar shift from the key.\r\n      state[j] = entangle(u, state) + k;\r\n    }\r\n    i++;\r\n  }\r\n\r\n  // create the final buffer\r\n  const rb = Buffer.alloc(state.length * 4);\r\n  state.forEach((v, idx) => {\r\n    const offset = idx * 4;\r\n    rb[offset] = (v >> 24) & 0xff;\r\n    rb[offset + 1] = (v >> 16) & 0xff;\r\n    rb[offset + 2] = (v >> 8) & 0xff;\r\n    rb[offset + 3] = v & 0xff;\r\n  });\r\n\r\n  return rb;\r\n}\r\n\r\nfunction sea256(s: string, key: string): Buffer;\r\nfunction sea256(s: string, key: string, encoding: BufferEncoding): string;\r\n\r\nfunction sea256(s: string, key: string, encoding?: BufferEncoding) {\r\n  const sbuf = Buffer.from(s, \"utf-8\");\r\n  const keybuf = Buffer.from(key, \"utf-8\");\r\n\r\n  if (encoding) {\r\n    return sea256Raw(sbuf, keybuf).toString(encoding);\r\n  }\r\n\r\n  return sea256Raw(sbuf, keybuf);\r\n}\r\n// export\r\nexport { sea256 };\r\n\r\n// run if main\r\n// __filename replacement\r\n"],
  "mappings": "AAAA,OAAS,UAAAA,MAAc,cAGvB,IAAMC,EAAS,CACb,cAAe,IAAI,YAAY,CAM7B,OACA,KAAK,MAAM,OAAU,UAAU,IAAM,EACrC,KAAK,MAAM,KAAK,KAAK,OAAS,OAAa,CAAC,IAAM,EAClD,KAAK,MAAM,KAAK,KAAK,UAAa,CAAC,EACnC,KAAK,MAAM,KAAK,KAAK,UAAa,CAAC,EAMnC,KAAK,MAAM,KAAK,KAAK,UAAU,CAAC,EAChC,KAAK,MAAM,KAAK,KAAK,UAAU,CAAC,EAChC,KAAK,MAAM,KAAK,KAAK,UAAU,CAAC,CAClC,CAAC,EACD,cAAe,EACf,eAAgB,EAChB,YAAa,CAEX,MAAO,WAGP,KAAM,WAGN,KAAM,WAGN,SAAU,SACZ,EAGA,QAAS,EAGT,cAAe,CACjB,EAMMC,EAAUC,GAAsBA,IAAM,EAGtCC,EAAO,CAACD,EAAW,KACrBA,GAAK,EAAMA,IAAO,GAAK,KAAS,EAG9BE,EAAO,CAACF,EAAW,KACrBA,IAAM,EAAMA,GAAM,GAAK,KAAS,EAG9BG,EAAY,CAACC,EAAeC,KAC/BD,EAAQC,IAASD,EAAQC,GAItBC,EAAa,CAACF,EAAeC,EAAcE,IAAsB,CAErE,GAAM,CAAE,MAAAC,EAAO,KAAAC,EAAM,KAAAC,EAAM,SAAAC,CAAS,EAAIb,EAAO,YAM3Cc,EAAIb,EAAQS,EAAQL,EAAUC,EAAOC,CAAI,GAAM,CAAC,EAGpD,OAAAO,EAAKA,EAAIL,EAAIE,IAAU,EAIvBG,EAAIX,EAAKW,EAAIF,EAAMZ,EAAO,OAAO,EAGjCc,EAAIb,EAAOa,EAAID,CAAQ,EAChBC,CACT,EAYMC,EAAW,CAACC,EAAWP,IAAsB,CAEjD,IAAMH,EAAQH,EAAKa,EAAIP,EAAGT,EAAO,aAAa,EAGxCO,EAAOH,EAAKH,EAAOe,EAAIP,CAAC,EAAGT,EAAO,cAAc,EAGhDiB,EAAQT,EAAWF,EAAOC,EAAME,CAAC,EAGvC,OAAOR,EAAOK,EAAQC,EAAOU,CAAK,CACpC,EAIMC,EAAW,CAACF,EAAWP,IAAsB,CACjD,IAAIU,EAAMH,EACV,QAASI,EAAI,EAAGA,EAAIpB,EAAO,cAAeoB,IACxCD,EAAMJ,EAASI,EAAKV,CAAC,EAEvB,OAAOU,CACT,EAGME,EAAW,CAACZ,EAAWa,IAA8B,CACzD,IAAIC,EAAOD,EAAK,CAAC,EACjB,QAASF,EAAI,EAAGA,EAAIE,EAAK,OAAQF,IAC/BG,EAAOL,EAASjB,EAAOsB,EAAOD,EAAKF,CAAC,CAAC,EAAGX,CAAC,EAE3C,OAAOc,CACT,EAOMC,EAAa,CAACR,EAAeI,IAAsBJ,EAAEI,EAAIJ,EAAE,MAAM,GAAK,EAI5E,SAASS,EAAUC,EAAeC,EAAqB,CACrD,IAAMC,EAAQ5B,EAAO,cAAc,MAAM,EACrCoB,EAAI,EAER,QAAW,KAAKM,EAAO,CACrB,IAAMG,EAAIL,EAAWG,EAAKP,CAAC,EAG3B,QAASU,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAGhCF,EAAME,CAAC,EAAIT,EAAS,EAAGO,CAAK,EAAIC,EAElCT,GACF,CAGA,IAAMW,EAAKhC,EAAO,MAAM6B,EAAM,OAAS,CAAC,EACxC,OAAAA,EAAM,QAAQ,CAACI,EAAGC,IAAQ,CACxB,IAAMC,EAASD,EAAM,EACrBF,EAAGG,CAAM,EAAKF,GAAK,GAAM,IACzBD,EAAGG,EAAS,CAAC,EAAKF,GAAK,GAAM,IAC7BD,EAAGG,EAAS,CAAC,EAAKF,GAAK,EAAK,IAC5BD,EAAGG,EAAS,CAAC,EAAIF,EAAI,GACvB,CAAC,EAEMD,CACT,CAKA,SAASI,EAAOC,EAAWT,EAAaU,EAA2B,CACjE,IAAMC,EAAOvC,EAAO,KAAKqC,EAAG,OAAO,EAC7BG,EAASxC,EAAO,KAAK4B,EAAK,OAAO,EAEvC,OAAIU,EACKZ,EAAUa,EAAMC,CAAM,EAAE,SAASF,CAAQ,EAG3CZ,EAAUa,EAAMC,CAAM,CAC/B",
  "names": ["Buffer", "config", "wrap32", "x", "rotL", "rotR", "zetaValue", "alpha", "beta", "gammaValue", "u", "scale", "grow", "flip", "collapse", "z", "hashByte", "b", "gamma", "roundMix", "val", "i", "entangle", "args", "prev", "shiftValue", "sea256Raw", "bytes", "key", "state", "k", "j", "rb", "v", "idx", "offset", "sea256", "s", "encoding", "sbuf", "keybuf"]
}
